# JS/React frontend
- [JS/React frontend](#jsreact-frontend)
- [Что это такое](#Что-это-такое)
- [Глоссарий](#Глоссарий)
- [Легкие проекты](#Легкие-проекты)
- [Проект: Список дел](#Проект-Список-дел)
  - [Компонент: Строка ввода нового дела](#Компонент-Строка-ввода-нового-дела)
    - [Импорт и экспорт](#Импорт-и-экспорт)
  - [State: Состояние компонента](#state-Состояние-компонента)
  - [События](#События)
  - [Props: Свойства компонента](#props-Свойства-компонента)

# Что это такое
Это руководство по созданию веб-приложений с использованием React.js для начинающих. 
Здесь мы напишем несколько приложений. Сначала будет несколько простых, в которых мы познакомимся с основами React.js, после них будет несколько сложных, в которых мы углубим эти знания.

Каждый новый проект мы будем начинать с чистой заготовки проекта (если не сказано обратное). Инструкция по созданию такой заготовки находится [здесь](new-project.html)

# Глоссарий
Эти понятия и названия будут время от времени употребляться в тексте, их необязательно понимать сразу

**Javascript (JS/ЖС)** — Язык программирования

**Node.js** — Интерпретатор JS, то есть программа, которая исполняет код на JS.

**NPM (Node.js Package Manager)** — Пакетный менеджер для Node.js, программа, которая устанавливает опубликованные другими людьми библиотеки (пакеты). Он также помогает запускать приложение

**NPX** — программа, которая скачивает некоторый пакет из NPM и выполняет определенный скрипт из него. Некоторые пакеты (create-react-app, который мы будем использовать) не используются в проекте непосредственно, они нужны для того, чтоб устанавливать другие проекты

**React.js** — програмный комплекс (*фреймворк*) для создания веб-приложений

**JSX** — диалект JS, обеспечивающий простоту написания HTML-компонентов приложения

<!-- **Babel** — библиотека для сборки приложения. Он объединяет все JS/JSX файлы в один, который уже исполняется в браузере.  -->

# Легкие проекты
1. Cчетчик нажатий
2. Список дел

# Проект: Список дел

Начнем обучение с небольшого проекта, который будет содержать поле для ввода дел и список этих самых дел

![todo](images/todo.png)

Основной сущностью в Реакте является **компонент**. Давай посмотрим, на какие компоненты можно разделить наше приложение:

- Строка ввода нового дела
  - Поле для ввода нового дела
  - Кнопка добавления
- Элемент списка дел, который состоит из
  - текста
  - кнопки удаления

Вот это как бы и получится "дерево" компонентов. Элементов списка дел может быть сколько угодно, поэтому для нас удобно иметь такой компонент, который мы можем переиспользовать сколько угодно раз


Так как это временный проект, создадим внутри `src`[^src] папку `todo`. Для этого в дереве файлов нажмем правой кнопкой на `src` и выберем "New Folder", введем ее название и нажмем "Enter"



## Компонент: Строка ввода нового дела

Внутри папки `todo` создадим файл первого компонента (правая кнопка -> New File), назовем его `field.jsx`

### Импорт и экспорт

Каждый компонент в Реакте — это функция, принимающая некоторые параметры (`props`) и возвращающая содержимое этого компонента. 

    function Field(props) {
      return <p>Hello, World!</p>
    }

Если мы хотим использовать этот компонент в каком-то другом файле, его надо экспортировать, приписав в начале определения ключевое слово `export`:

    export function Field(props) {
      return <p>Hello, World!</p>
    }

Теперь эту функцию можно использовать в других местах

Откроем заново `src/App.jsx` и удалим все внутри `<div className="App">`. Функция App должна принять такой вид:
    
    import React from "react";
    import "./App.css";
    
    function App() {
      return (
        <div className="App">

        </div>
      );
    }

Обрати внимание на удаленный `import logo (...)`. Он нам тоже больше не нужен, так как мы удалили использующий его `<img>`

Откроем `src/App.css` и удалим все его содержимое. Эти стили нужны были для демо-страницы, больше они не пригодятся

В дальнейшем вместо `<div className="App">` я буду писать `div.App`. Это короче, и такой синтаксис используется в CSS[^css-selectors]


Теперь давай добавим наш компонент `Field` в `App`:

    <div className="App">
      <Field/>
    </div>

Упс! `Field` подсветился красной линией, а в консоли появилась ошибка:

    Failed to compile.
    
    ./src/App.jsx
      Line 9:8:  'Field' is not defined  react/jsx-no-undef

Главная ошибка новичка состоит в том, что они **не читают сообщения об ошибках**, а сразу начинают паниковать. Однако в 80% случаев в сообщении об ошибке есть ясная информация о том, что пошло не так. В данном случае у нас ошибка в файле `./src/App.jsx` на 9й строке и 8м символе. Сборщик не знает, что такое Field. Нужно импортировать `Field` из `field.jsx`.

Добавим эту строку вверх к остальным импортам:

    import { Field } from "./todo/field";

Опять ошибка! **'React' must be in scope when using JSX**, уже в `field.jsx`

За загадочным описанием кроется всего лишь то, что нам надо импортировать библиотеку Реакта[^jsx-react-scope]. Импортируем его в `field.jsx` самой первой строчкой:

    import React from "react";

    export function Field() {
      return <p>Hello, World!</p>
    }

**Compiled successfully!** Ура! Смотрим в браузер

## State: Состояние компонента
Зачастую нам нужно, чтобы компоненты имели какое-то состояние. Чекбокс хранит информацию о том, что он отмечен. Поле ввода хранит информацию о своем тексте. Список дел хранит... список дел!

Для того, чтобы хранить состояние, в Реакте есть функция `useState`. Давай сдеаем так, чтобы при каждом нажатии на "Hello, world!" у нас увеличивался счетчик и отображался рядом с надписью. 

    import React, { useState } from "react";

    export function Field() {
      const [counter, setCounter] = useState(0)
      return <p>Hello, World!</p>
    }

Обрати внимание на то, как странно выглядит теперь импорт. Я в будущем объясню почему так, на данный же момент просто запомни, что React импортируется без фигурных скобок вокруг, а `useState` (в будущем будут еще другие `useЧтотоЕще`)

`useState` принимает изначальное значение (0) и возвращает массив `[текущее_значение, функция_для_обновления_значения]`, которая в нашем коде "распадается" на, соответственно, `counter` и `setCounter`.

Сделаем так, что рядом с надписью отображается счетчик:

    return <p>Hello, World! {counter}</p>

Теперь добавим **обработчик нажатия** на наш текст. Внутри нашей функции создадим еще одну 😱:

    function increment() {
      setCounter(counter + 1);
    }

Здесь мы устанавливаем значение `counter` в `counter + 1`[^counter].

Теперь надо сделать так, чтобы обработчик `increment` вызывался при нажатии на текст:

    <p onClick={increment}>Hello, World! {counter}</p>;

Смотрим в браузер, кликаем мышкой по тексту!

## События

Теперь, когда мы научились пользоваться useState, применим его для хранения текстовых данных.

Для ввода текстовых данных есть тег `<input>`, у которого есть свойство `value` для текста и  `onChange` для обработки *изменений*, сродни `onClick` для нажатий. Следовательно, наш компонент будет выглядеть как-то так:

    import React, { useState } from "react";

    export function Field() {
      const [text, setText] = useState("");

      function onChange() {
        // ???
      }

      return <input value={text} onChange={onChange} />;
    }

Обрати внимание на `useState`: теперь изначальное значение — пустая строка.

Осталось понять, что делать в `onChange`. Внутри должен вызываться `setText`, но как получить новое значение текста? Когда ты редактируешь текст в инпуте, инпут создает так называемое `событие`. Есть много разных событий, (`click`, `change` — самые частоиспользуемые). onChange получает события изменения. Как же достать новый текст из события изменения? В дальнейшем мы научимся смотреть то, какие данные у нас передаются, но пока просто запомним, что новое значение хранится в `e.target.value`, где `e` — объект события:
 
    function onChange(e) {
      setText(e.target.value);
    }

Вуаля! Теперь мы можем редактировать значение поля ввода! Мы это и раньше могли бы делать, но теперь мы храним его в нашем `useState`

## Props: Свойства компонента
     
    
...To be continued
   
[^src]: src — сокращение от 'source' — "исходный код"

[^jsx-react-scope]: При сборке приложения весь JSX синтаксис "компилируется" в обычный JS, которому нужен React, поэтому нам надо его импортировать, несмотря на то, что явно мы его не используем


[^counter]: Почему бы не написать `counter = counter + 1`? Или, еще короче, `counter++`? `UseState` интегрируется с Реактом и предоставляет возможность хранить нектоторые данные, а так же понимать, что данные изменились и надо обновить компонент. Будь `counter` локальной переменной, у Реакта не было бы возможности понять, что что-то изменилось.



